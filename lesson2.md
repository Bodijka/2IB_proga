# bin1.exe

В данном бинарнике все предельно просто, программа запрашивает на ввод строку и посимвольно (с помощью `scanf`) сверяет ее с строкой `"VaL1DP@$$w0rD"`.

<img width="1919" height="1079" alt="Binarnik1" src="https://github.com/user-attachments/assets/20c852e5-0f74-4a2e-91ed-f354b3939c3b" />

### Ответ: `VaL1DP@$$w0rD`



# bin2.exe

Программа принимает на ввод строку. Ее длина должна быть `= 6`.
Далее программа пробегает по индексам и сверяет их с константами, если все верно - проверка пройдена.
`0 == q`
`1 == w`
`2 == e`
`3 == r`
`4 == t`
`5 == y`

<img width="1919" height="1079" alt="Binarnik2" src="https://github.com/user-attachments/assets/defe5256-8a00-4536-afdf-f13b230bdc40" />


### Ответ: `qwerty`

# bin3.exe

Тут принцип довольно прост. Программа принимает нашу строку и "склеивает" её с константной строкой `0xjfkD2`

Итоговый ответ должен выглядеть так: `"строка пользователя" + "0xjfkD2"`

<img width="1919" height="1079" alt="Binarnik3" src="https://github.com/user-attachments/assets/e776dfa5-e437-4cb2-8078-6c2b2cf56716" />


### Ответ: `btc0xjfkD2` (где "btc" - моя введеная строка)


# bin4.exe

Тут все гораздо интереснее. Программа считывает файлы в той же директории где находится сам. Он считывает файлы Hello1 и Hello2.

Далее следует 2 проверки:

Функция check - проверяет чтобы строки были "зеркальными" *(пример абв == вба)*

Функция сheck2 - проверяет то, чтобы та "зеркальная" строка была равна этой, что в проверке. Глядя на функцию, можно понять какой должна быть эта строка. 

![photo_2025-10-03_17-03-25](https://github.com/user-attachments/assets/a4d20a59-d9b7-4981-a87e-002324e0185f)

!К скриншоту выше! Мы видим, что у программы есть константы, а некоторые константы, в свою очередь, равны другим индексам.
`[0] == z` - константа. Но `[0] == [6]`, значит и символ под 6 индексом равен `z`.
`[7] == s` - константа. Но `[7] == [3]`, а `[3] == [2]`, значит все эти индексы равны `s`.

Такая проверка не везде. Чтобы найти, какой символ под 4 инексом:
``if ( a1[5] - a1[4] != 8 )``

Нужно из `[5]` вычесть `8` (по таблице ASCII). `105 - 8 = 97`. 97 соответствует символу `a` (по ASCII).

Нужно теперь вписать в созданные `Hello1` и `Hello2` - `zfssaizs` и `sziassfz` соответсвенно. Тогда в консоли отобразится "флаг".

<img width="1919" height="1079" alt="Binarnik4" src="https://github.com/user-attachments/assets/56edb1ea-7610-49c6-a8a6-a5da4d0cf82d" />


### Ответ: `Flag{zfssaizs}`

# bin5.exe

Программа проверяет, что длина строки равна `7`, а первый символ равен `а`.
Далее строка должна удовлетворять функции `check`:

`Buf[0] = 'a'`

`Buf[1] = 'a' + 1 = 'b'`

`Buf[2] = 'b' + 2 = 'd'`

`Buf[3] = 'd' + 3 = 'g'`

`Buf[4] = 'g' + 4 = 'k'`

`Buf[5] = 'k' + 5 = 'p'`

C каждым разом код буквы (по ASCII) увеличивается на +1. Арифметиеская прогрессия с шагом +1.
Соблюдаем это условие до `6` элемента, а далее у нас нет конкретики. Функция проверяет первые `6` символов, а в самом начале проверка то, что длина строки должна быть `7`. Вписываем любой символ чтобы уложиться в заданую длину и получаем верный ответ.

<img width="1919" height="1079" alt="Binarnik5" src="https://github.com/user-attachments/assets/e6daa8b7-ff16-449f-85fd-2e333f4eb7ef" />



### Ответ: `abdgkp*` (где * - произвольный символ)
